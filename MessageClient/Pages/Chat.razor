@page "/"
@using MessageClient.Models
@inject HttpClient Http

<MudTextField @bind-Value="newMessage" Label="Enter your message" Variant="Variant.Filled" />
<MudButton OnClick="SendMessage" Color="Color.Primary">Send</MudButton>

<MudList T="string">
    @foreach (var message in messages)
    {
        <MudListItem>
            <MudText Typo="Typo.body1">@message.Content</MudText>
            <MudText Typo="Typo.caption">@message.Timestamp.ToLocalTime().ToString("T")</MudText>

            <!-- Поле для изменения сообщения -->
            <MudTextField @bind-Value="message.Content" Label="Изменить сообщение" />

            <!-- Кнопка для отправки обновленного сообщения на API -->
            <MudButton Color="Color.Primary" OnClick="@(() => UpdateMessage(message))">
                Обновить сообщение
            </MudButton>
        </MudListItem>
    }
    </MudList>

    @code {
    private string newMessage;
    private List<Message> messages = new();

    protected override async Task OnInitializedAsync()
    {
        messages = await Http.GetFromJsonAsync<List<Message>>("api/Messages");
    }

    private async Task SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(newMessage))
        {
            var response = await Http.PutAsJsonAsync("api/Messages/{id}", newMessage);
            if (response.IsSuccessStatusCode)
            {
                newMessage = string.Empty;
                messages = await Http.GetFromJsonAsync<List<Message>>("api/Messages");
            }
        }
    }

    private async Task UpdateMessage(Message message)
    {
        // Здесь вы можете реализовать логику отправки обновленного сообщения на API
        using var httpClient = new HttpClient();
        var response = await httpClient.PutAsJsonAsync($"api/Messages/{message.Id}", message);

        
    }
}
